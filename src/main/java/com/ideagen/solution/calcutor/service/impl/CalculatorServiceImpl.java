package com.ideagen.solution.calcutor.service.impl;

import java.util.ArrayList;
import java.util.List;

import com.ideagen.solution.calculator.exceptions.CalculatorException;
import com.ideagen.solution.calculator.objects.Token;
import com.ideagen.solution.calculator.objects.TokenSeperatorObject;
import com.ideagen.solution.calculator.service.CalculatorService;

public class CalculatorServiceImpl implements CalculatorService{

	/**
	 * Seperating Tokens from String. Any Brackated Value is a token. Numerics are also
	 * Tokens. Operators involving outer most value is stored in different Array
	 * @param expression expressionString being passed into functions
	 * @exception CalculatorException TokenSeperatorException thrown if exception thrown in this function
	 * @return TokenSeperatorObject contains List of Tokens that has been seperated as well as List of Characters containing the operators
	 */
	public TokenSeperatorObject tokenSeperator(String expression) throws CalculatorException{
		int bracketCounter = 0;
		String tempExpression = null;
		Token currentToken = null;
		String tempDigit = "";


		List<Token> tokenList = new ArrayList<Token>();
		List<Character> characterList = new ArrayList<Character>();//Stores Operator tokens

		try {
			for (Character ch:expression.toCharArray()) {
				if (bracketCounter == 0) {
					tempExpression = "";
					currentToken = null;
				}
				if (ch.equals('(')) {
					Token token = new Token();
					token.setExpression("");

					if (bracketCounter > 0) {
						if (!tokenList.contains(currentToken)) {
							currentToken.setId(tokenList.size());
							tokenList.add(currentToken);
						}
						token.setId(tokenList.size());
						token.setParentId(currentToken.getId());
						tempExpression = tempExpression + "^" + token.getId() + "^";
						currentToken.setExpression(tempExpression);
						currentToken = token;
						tempExpression = "";
					} else {
						currentToken = token;
					}
					bracketCounter++;
				} else {
					if (bracketCounter > 0) {
						if (ch.equals(')')) {
							bracketCounter--;
							currentToken.setExpression(tempExpression);
							if (!tokenList.contains(currentToken)) {
								currentToken.setId(tokenList.size());
								tokenList.add(currentToken);
							}
							if (bracketCounter > 0) {
								currentToken = tokenList.get(currentToken.getParentId());
								tempExpression = currentToken.getExpression();
							}
						} else {
							tempExpression = tempExpression + ch;
						}

					} else {
						if (Character.isDigit(ch) || ch == '.') {
							tempDigit = tempDigit + ch;
						} else {
							if (!tempDigit.equals("")) {
								Token token = new Token();
								token.setExpression(tempDigit);
								token.setId(tokenList.size());
								tokenList.add(token);
								tempDigit = "";
							}
							characterList.add(ch);
						}
					} 
				}
			}

			if (!tempDigit.equals("")) {
				Token token = new Token();
				token.setExpression(tempDigit);
				token.setId(tokenList.size());
				tokenList.add(token);
			}
		} catch (Exception e) {
			throw new CalculatorException();
		}

		TokenSeperatorObject tokenSeperatorObject = new TokenSeperatorObject();
		tokenSeperatorObject.setCharacterList(characterList);
		tokenSeperatorObject.setTokenList(tokenList);
		return tokenSeperatorObject;
	}

	/**
	 * Start Processing the inner most Bracket Values and then Propagating to upper most Bracket Values.
	 * @param tokenList List of Tokens that are created by processing earlier expression
	 * @exception CalculatorException TokenSeperatorException thrown if exception thrown in this function
	 * @return List<Token> A more refined List of tokens which are generated by processing the inner most bracket values. 
	 * We expect not to have any more inner most bracket values after processing
	 */
	public List<Token> expressionInnerMostProcessing(List<Token> tokenList) throws CalculatorException{
		//Start Processing the inner most Bracket Values and then Propagating to upper most Bracket Values
		ArrayList<Integer> processedList = new ArrayList<Integer>();
		try {
			for (Token token:tokenList) {
				if (!token.getExpression().contains("^") ) {
					processedList.add(token.getId());
				}
			}
			while (true) {
				ArrayList<Integer> processedList2 = new ArrayList<Integer>();
				for (int i =0;i<processedList.size();i++) {
					Token token = tokenList.get(processedList.get(i));
					String evaluated = evaluate(token.getExpression());
					token.setExpression(evaluated);
					if (token.getParentId() != -1) {
						Token tokenParent = tokenList.get(token.getParentId());
						String evaluated2 = tokenParent.getExpression();
						String replaceString = "^" + token.getId() +"^";

						String replaced = evaluated2.replace(replaceString, evaluated);

						if (!replaced.contains("^")) {
							processedList2.add(token.getParentId());
						}
						tokenParent.setExpression(replaced);
					}
				}
				if (processedList2.size() == 0) {
					break;
				} else {
					processedList = new ArrayList<Integer>();
					processedList.addAll(processedList2);
				}
			}
		} catch (Exception e) {
			throw new CalculatorException();
		}
		return tokenList;
	}

	/**
	 * Processing the outer most token and perform arithmatic operations
	 * @param tokenList List of Tokens that are created by processing earlier expression
	 * @exception CalculatorException TokenSeperatorException thrown if exception thrown in this function
	 * @return List<Double> Double values that remain after processing the outer most(Non Bracket) operations
	 */
	public List<Double> expressionOuterMostProcessing(List<Token> tokens) throws CalculatorException {
		//Once Value propagated up. Just take the "outer most" token and perform arithmatic operations
		List<Double> doubleList = new ArrayList<Double>();	
		try {
			for (Token t: tokens) {
				if (t.getParentId() == -1) {
					doubleList.add(Double.valueOf(t.getExpression()));
				}
			}
		} catch (Exception e) {
			throw new CalculatorException();
		}
		return doubleList;
	}

	/**
 	 *  Produces a Double Value from an expression. Expression only contains
	 *  numerical values and arithmetic operators
	 * @param expression String expression that needs to be evaluate
	 * @exception CalculatorException TokenSeperatorException thrown if exception thrown in this function
	 * @return numeric values after processing in String form
	 */
	private  String evaluate(String expression) throws CalculatorException {
		ArrayList<Character> characterList = new ArrayList<Character>();
		ArrayList<Double> doubleList = new ArrayList<Double>();
		String tempDigit = "";
		for (Character ch:expression.toCharArray()) { 
			if (Character.isDigit(ch) || ch == '.') {
				tempDigit = tempDigit + ch;
			} else {
				if (!tempDigit.equals("")) {
					doubleList.add(Double.valueOf(tempDigit));
					tempDigit = "";
				}
				characterList.add(ch);
			}
		}

		if (!tempDigit.equals("")) {
			doubleList.add(Double.valueOf(tempDigit));
		}

		String processListString = null;
		try {
			processListString = String.valueOf(processList(doubleList, characterList));
		} catch (CalculatorException e) {
			throw new CalculatorException();
		}

		return String.valueOf(processListString);
	}

	
	/**
 	 *  Final Processing that produces result
 	 *  Process multiplier and divider first. Then process other operators later
	 * @param doubleList List of remaining doubles that needs to be processed
	 * 	      characterList operators that will be operated on the remaining double
	 * @exception CalculatorException TokenSeperatorException thrown if exception thrown in this function
	 * @return final value that will be returned
	 */
	public  Double processList(List<Double> doubleList, List<Character> characterList) throws CalculatorException {
		int index = 0;

		while (characterList.contains('*') ) {
			index = characterList.lastIndexOf('*');
			characterList.remove(index);
			doubleList.set(index, doubleList.get(index) * doubleList.get(index + 1));
			doubleList.remove(doubleList.get(index + 1));
		}

		while (characterList.contains('/') ) {
			index = characterList.lastIndexOf('/');
			characterList.remove(index);
			doubleList.set(index, doubleList.get(index) / doubleList.get(index + 1));
			doubleList.remove(doubleList.get(index + 1));
		}

		Double returnDouble = doubleList.get(0);
		for (int i =0;i<characterList.size();i++) {
			if (characterList.get(i) == '+') {
				returnDouble = returnDouble + doubleList.get(i + 1);
			} else {
				returnDouble = returnDouble - doubleList.get(i + 1);
			}

		}
		return returnDouble;
	}



}
